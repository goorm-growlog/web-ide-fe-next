# 협업 에디터 아키텍처 - 웹소켓과 HocusPocus 연결 구조

## 🏗️ 전체 아키텍처 개요

이 프로젝트는 **Next.js + Monaco Editor + Yjs + HocusPocus**를 활용한 실시간 협업 코드 에디터입니다. HocusPocus Provider를 통해 백엔드 웹소켓 서버와 연결되어 실시간 문서 동기화와 협업 기능을 제공합니다.

```
Frontend (Next.js)
├── Monaco Editor UI
├── Yjs Document (CRDT)
├── HocusPocus Provider (WebSocket Client)
└── WebSocket Pool Manager
                ↕ WebSocket Connection
Backend WebSocket Server
├── HocusPocus Server
├── Room Management (project-{projectId}-{fileId})
└── Yjs Document Synchronization
```

## 📁 핵심 파일별 역할 분석

### 1. 웹소켓 연결 관리층

#### `src/features/editor/model/websocket-pool.ts`

**역할**: 웹소켓 연결의 전체 생명주기를 관리하는 싱글톤 풀 매니저

**주요 기능**:

- **LRU 기반 탭 관리**: 최대 5개 탭까지 동시 연결 허용
- **연결 풀링**: HocusPocus Provider 인스턴스 재사용으로 성능 최적화
- **Room 네이밍**: `project-{projectId}-{fileId}` 형식으로 백엔드 룸과 매칭

**백엔드 연결 설정**:

```typescript
private wsUrl = process.env.NEXT_PUBLIC_YJS_WEBSOCKET_URL || "ws://localhost:3001";

const provider = new HocuspocusProvider({
  url: this.wsUrl,           // 백엔드 웹소켓 URL
  name: roomName,            // project-{projectId}-{fileId}
  document: fileDoc,         // Yjs 문서 인스턴스
});
```

**HocusPocus 연결 흐름**:

1. 새 파일 열기 → `getFileDocument()` 호출
2. Y.Doc 생성 (guid: fileId)
3. HocusPocus Provider 생성 및 백엔드 연결
4. `synced` 이벤트 대기 → Monaco 모델 업데이트
5. Awareness 설정 (사용자 정보 + 활성 파일)

#### `src/features/editor/ui/WebSocketCleanup.tsx`

**역할**: 애플리케이션 종료 시 웹소켓 연결 정리

**정리 시점**:

- `beforeunload` 이벤트 (브라우저 종료/새로고침)
- `unload` 이벤트 (페이지 이탈)
- 컴포넌트 언마운트

### 2. 세션 관리층

#### `src/features/editor/model/useYjsSessionStore.ts`

**역할**: Yjs 세션과 Monaco Editor 모델의 바인딩 관리

**세션 생명주기**:

1. **openSession**: WebSocket Pool에서 Y.Doc/Provider 획득 → Monaco 모델 생성
2. **connectEditorToSession**: MonacoBinding 생성 (Y.Doc ↔ Monaco 양방향 동기화)
3. **closeSession**: Binding/Model 정리 + WebSocket Pool 연결 해제

**HocusPocus 동기화 처리**:

```typescript
// 서버 동기화 완료 후 Monaco 모델 업데이트 콜백
(syncedYDoc) => {
  const syncedContent = syncedYDoc.getText("monaco").toString();
  if (session.textModel.getValue() !== syncedContent) {
    session.textModel.setValue(syncedContent);
  }
};
```

### 3. 탭 및 파일 관리층

#### `src/features/editor/model/use-panes-store.ts`

**역할**: 에디터 탭 상태 관리 및 파일 열기/닫기 제어

**탭 관리 흐름**:

- `openFileInEditor`: 세션 생성 → 탭 추가 → 활성 탭 설정
- `closeTab`: 세션 정리 → 탭 제거 → 다음 활성 탭 선택
- `setActiveFileId`: 탭 전환 시 세션 확인 및 복구

### 4. 에디터 연결 관리층

#### `src/features/editor/lib/hooks/useEditorSessionManager.ts`

**역할**: Monaco Editor 인스턴스와 활성 파일 세션의 실시간 연결 관리

**연결 관리 프로세스**:

1. 활성 파일 변경 감지
2. 이전 파일 뷰 상태 저장 + 에디터 연결 해제
3. 새 파일 모델 설정 + 바인딩 연결
4. Awareness 사용자 정보 업데이트
5. 뷰 상태 복원

### 5. 실시간 협업 UI층

#### `src/features/editor/cursor/ui/Cursors.tsx`

**역할**: 협업자의 실시간 커서 및 선택 영역 시각화

**Awareness 기반 협업 표시**:

- HocusPocus Provider의 Awareness API 활용
- 같은 파일을 보는 사용자만 필터링
- 동적 CSS 생성으로 사용자별 커서 스타일 적용

## 🔄 HocusPocus 백엔드 연결 흐름

### 1. 연결 설정 및 초기화

```
[Frontend] websocket-pool.ts
    ↓ new HocuspocusProvider({ url, name, document })
[WebSocket] ws://localhost:3001
    ↓ Room: "project-{projectId}-{fileId}"
[Backend] HocusPocus Server
    ↓ Y.Doc synchronization
[Shared State] Yjs CRDT Document
```

### 2. 실시간 동기화 프로세스

```
[User A] Monaco Editor 입력
    ↓ MonacoBinding
[Yjs] Y.Text 업데이트 (Operation)
    ↓ HocusPocus Provider
[WebSocket] Binary Protocol (Yjs Update)
    ↓ 백엔드 Room Broadcasting
[WebSocket] → [User B, C, D...]
    ↓ HocusPocus Provider 수신
[Yjs] Y.Doc 자동 병합 (CRDT)
    ↓ MonacoBinding
[Monaco] Editor 자동 업데이트
```

### 3. Awareness 협업 정보 동기화

```
[Frontend] setLocalStateField('user', userInfo)
    ↓ HocusPocus Awareness
[WebSocket] JSON Protocol (User State)
    ↓ 백엔드 Awareness Broadcasting
[Frontend] awareness.on('change', callback)
    ↓ Cursors 컴포넌트
[UI] 실시간 커서/선택영역 표시
```

## 📋 핵심 기술 스택

### Frontend Dependencies

- **@hocuspocus/provider**: WebSocket 기반 Yjs Provider
- **yjs**: CRDT 기반 실시간 문서 동기화
- **y-monaco**: Yjs와 Monaco Editor 바인딩
- **@monaco-editor/react**: Monaco Editor React 컴포넌트
- **zustand**: 상태 관리

### 연결 설정

- **WebSocket URL**: `process.env.NEXT_PUBLIC_YJS_WEBSOCKET_URL` (기본값: ws://localhost:3001)
- **Room 네이밍**: `project-{projectId}-{fileId}`
- **Document ID**: `fileId` (Y.Doc guid)

## 성능 최적화 전략

### 1. 연결 풀링

- 최대 5개 탭 동시 연결 제한
- LRU 알고리즘으로 오래된 연결 자동 해제
- Provider 인스턴스 재사용으로 메모리 최적화

### 2. 세션 관리

- 탭 닫기 시 즉시 해제하지 않고 연결만 끊어 재연결 시 빠른 복구
- MonacoBinding 지연 생성 (에디터 연결 시점)
- ViewState 자동 저장/복원으로 사용자 경험 향상

### 3. 협업 최적화

- 같은 파일을 보는 사용자만 커서 표시 필터링
- Awareness 상태 변경 이벤트 기반 효율적 UI 업데이트
- CSS 동적 생성으로 불필요한 DOM 조작 최소화
